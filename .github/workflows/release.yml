name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version to release (e.g., v1.0.0)'
        required: true
        type: string

jobs:
  # Create release
  create-release:
    name: Create Release
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Get version
      id: version
      run: |
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "version=${{ github.event.inputs.version }}" >> $GITHUB_OUTPUT
        else
          echo "version=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        fi

    - name: Create release
      id: create_release
      uses: actions/create-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        tag_name: ${{ steps.version.outputs.version }}
        release_name: SatsConnect ${{ steps.version.outputs.version }}
        body: |
          ## ğŸš€ SatsConnect ${{ steps.version.outputs.version }}
          
          ### âœ¨ What's New
          - Enhanced security with JWT authentication
          - Improved Lightning Network integration
          - Better mobile app performance
          - Comprehensive monitoring and alerting
          
          ### ğŸ”§ Technical Improvements
          - Updated dependencies
          - Enhanced error handling
          - Improved logging and auditing
          - Better test coverage
          
          ### ğŸ“± Mobile App
          - Biometric authentication
          - Secure key storage
          - Improved UX/UI
          - Better offline support
          
          ### ğŸ”’ Security
          - Encrypted configuration
          - Rate limiting
          - Input validation
          - Audit logging
          
          ### ğŸ“Š Monitoring
          - Health checks
          - Performance metrics
          - Error tracking
          - Security monitoring
        draft: false
        prerelease: false

  # Build and test
  build-and-test:
    name: Build and Test
    runs-on: ubuntu-latest
    needs: create-release

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Setup Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        components: rustfmt, clippy

    - name: Install dependencies
      run: |
        cd backend/node-orchestrator
        npm ci
        cd ../../mobile
        npm ci

    - name: Build Rust engine
      run: |
        cd backend/rust-engine
        cargo build --release

    - name: Build Node.js orchestrator
      run: |
        cd backend/node-orchestrator
        npm run build

    - name: Run tests
      run: |
        echo "ğŸ§ª Running comprehensive test suite..."
        
        # Run Rust tests
        cd backend/rust-engine
        cargo test
        
        # Run Node.js tests
        cd ../node-orchestrator
        npm test
        
        # Run mobile tests
        cd ../../mobile
        npm test

    - name: Run security scans
      run: |
        echo "ğŸ”’ Running security scans..."
        
        # Run npm audit
        cd backend/node-orchestrator
        npm audit --audit-level=moderate
        
        cd ../../mobile
        npm audit --audit-level=moderate
        
        # Run cargo audit
        cd ../rust-engine
        cargo audit

  # Build Docker images
  build-docker:
    name: Build Docker Images
    runs-on: ubuntu-latest
    needs: create-release

    strategy:
      matrix:
        service: [rust-engine, node-orchestrator]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ghcr.io/${{ github.repository }}/${{ matrix.service }}
        tags: |
          type=ref,event=tag
          type=raw,value=latest

    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: ./backend/${{ matrix.service }}
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Build mobile app
  build-mobile:
    name: Build Mobile App
    runs-on: ubuntu-latest
    needs: create-release

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        cache: 'npm'

    - name: Install dependencies
      run: |
        cd mobile
        npm ci

    - name: Install EAS CLI
      run: npm install -g @expo/eas-cli

    - name: Login to EAS
      run: |
        cd mobile
        eas login --non-interactive
      env:
        EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

    - name: Build mobile app
      run: |
        cd mobile
        eas build --platform all --profile production --non-interactive
      env:
        EXPO_TOKEN: ${{ secrets.EXPO_TOKEN }}

  # Upload release assets
  upload-assets:
    name: Upload Release Assets
    runs-on: ubuntu-latest
    needs: [create-release, build-and-test, build-docker, build-mobile]

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Download Docker images
      run: |
        echo "ğŸ“¦ Downloading Docker images..."
        # Download built images (in a real scenario, these would be pulled from registry)
        mkdir -p release-assets

    - name: Create release package
      run: |
        echo "ğŸ“¦ Creating release package..."
        
        # Create release directory
        mkdir -p release-assets
        
        # Copy important files
        cp README.md release-assets/
        cp LICENSE release-assets/
        cp docker-compose.yml release-assets/
        cp docker-compose.prod.yml release-assets/
        
        # Copy configuration examples
        cp backend/node-orchestrator/.env.example release-assets/
        cp mobile/app.json release-assets/
        
        # Create installation script
        cat > release-assets/install.sh << 'EOF'
        #!/bin/bash
        echo "ğŸš€ Installing SatsConnect..."
        
        # Check if Docker is installed
        if ! command -v docker &> /dev/null; then
          echo "âŒ Docker is not installed. Please install Docker first."
          exit 1
        fi
        
        # Check if Docker Compose is installed
        if ! command -v docker-compose &> /dev/null; then
          echo "âŒ Docker Compose is not installed. Please install Docker Compose first."
          exit 1
        fi
        
        # Start services
        echo "ğŸƒ Starting services..."
        docker-compose up -d
        
        echo "âœ… SatsConnect installed successfully!"
        echo "ğŸŒ Access the API at: http://localhost:3000"
        echo "ğŸ“± Mobile app: Install from your app store"
        EOF
        
        chmod +x release-assets/install.sh
        
        # Create upgrade script
        cat > release-assets/upgrade.sh << 'EOF'
        #!/bin/bash
        echo "ğŸ”„ Upgrading SatsConnect..."
        
        # Stop services
        docker-compose down
        
        # Pull latest images
        docker-compose pull
        
        # Start services
        docker-compose up -d
        
        echo "âœ… SatsConnect upgraded successfully!"
        EOF
        
        chmod +x release-assets/upgrade.sh
        
        # Create uninstall script
        cat > release-assets/uninstall.sh << 'EOF'
        #!/bin/bash
        echo "ğŸ—‘ï¸ Uninstalling SatsConnect..."
        
        # Stop and remove services
        docker-compose down -v
        
        # Remove images
        docker rmi satsconnect-rust-engine satsconnect-node-orchestrator
        
        echo "âœ… SatsConnect uninstalled successfully!"
        EOF
        
        chmod +x release-assets/uninstall.sh

    - name: Upload release assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ needs.create-release.outputs.upload_url }}
        asset_path: ./release-assets
        asset_name: satsconnect-${{ github.ref_name }}-assets.zip
        asset_content_type: application/zip

  # Deploy to staging
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [create-release, build-and-test, build-docker]

    environment:
      name: staging
      url: https://staging.satsconnect.app

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to staging
      run: |
        echo "ğŸš€ Deploying to staging environment..."
        # Add your staging deployment commands here
        # Example: kubectl apply -f k8s/staging/
        # Example: docker-compose -f docker-compose.staging.yml up -d

    - name: Run smoke tests
      run: |
        echo "ğŸ§ª Running smoke tests..."
        # Add smoke tests here
        # Example: curl -f https://staging.satsconnect.app/health

    - name: Notify staging deployment
      run: |
        echo "âœ… Staging deployment completed!"
        echo "ğŸŒ Staging URL: https://staging.satsconnect.app"

  # Deploy to production
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [create-release, build-and-test, build-docker, deploy-staging]

    environment:
      name: production
      url: https://satsconnect.app

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Deploy to production
      run: |
        echo "ğŸš€ Deploying to production environment..."
        # Add your production deployment commands here
        # Example: kubectl apply -f k8s/production/
        # Example: docker-compose -f docker-compose.prod.yml up -d

    - name: Run production health checks
      run: |
        echo "ğŸ¥ Running production health checks..."
        # Add health checks here
        # Example: curl -f https://satsconnect.app/health

    - name: Notify production deployment
      run: |
        echo "âœ… Production deployment completed!"
        echo "ğŸŒ Production URL: https://satsconnect.app"

  # Release summary
  release-summary:
    name: Release Summary
    runs-on: ubuntu-latest
    needs: [create-release, build-and-test, build-docker, build-mobile, upload-assets, deploy-staging, deploy-production]
    if: always()

    steps:
    - name: Release summary
      run: |
        echo "ğŸ‰ Release Summary"
        echo "================="
        echo "âœ… Release created: ${{ needs.create-release.result }}"
        echo "âœ… Build and test: ${{ needs.build-and-test.result }}"
        echo "âœ… Docker build: ${{ needs.build-docker.result }}"
        echo "âœ… Mobile build: ${{ needs.build-mobile.result }}"
        echo "âœ… Assets uploaded: ${{ needs.upload-assets.result }}"
        echo "âœ… Staging deployment: ${{ needs.deploy-staging.result }}"
        echo "âœ… Production deployment: ${{ needs.deploy-production.result }}"
        
        if [[ "${{ needs.create-release.result }}" == "failure" || 
              "${{ needs.build-and-test.result }}" == "failure" || 
              "${{ needs.build-docker.result }}" == "failure" || 
              "${{ needs.build-mobile.result }}" == "failure" || 
              "${{ needs.upload-assets.result }}" == "failure" || 
              "${{ needs.deploy-staging.result }}" == "failure" || 
              "${{ needs.deploy-production.result }}" == "failure" ]]; then
          echo "âŒ Some release steps failed. Please review the results."
          exit 1
        else
          echo "âœ… Release completed successfully!"
        fi